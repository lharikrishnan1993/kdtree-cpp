\hypertarget{classkdtree}{}\section{kdtree$<$ fd $>$ Class Template Reference}
\label{classkdtree}\index{kdtree$<$ fd $>$@{kdtree$<$ fd $>$}}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classkdtree_a938fa159f9e1088db61c8fc34b2d31c9}{kdtree} ()
\begin{DoxyCompactList}\small\item\em Constructor for the kd tree. \end{DoxyCompactList}\item 
\hyperlink{classkdtree_aed5e97fa78a51ce22c83874f5ccfc91a}{$\sim$kdtree} ()
\begin{DoxyCompactList}\small\item\em Destructor for the kd tree. \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$ $>$ \hyperlink{classkdtree_a42af3021231ec8fceff78d6f309d2571}{insert\+\_\+kdtree} (std\+::vector$<$ fd $>$ \&data)
\begin{DoxyCompactList}\small\item\em Creates the root, if it is null, else, passes it to the another insert function which performs the same function recursively. \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$ $>$ \hyperlink{classkdtree_a6ecd469b21764e96fd222835bef0ed0c}{insert\+\_\+kdtree} (std\+::vector$<$ fd $>$ \&data, std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$$>$ subtree, size\+\_\+t depth=0, bool collsion\+\_\+level=0)
\begin{DoxyCompactList}\small\item\em the fundamental logic of insertion in kd tree and the explaination can be found at \href{https://web.stanford.edu/class/cs106l/handouts/assignment-3-kdtree.pdf}{\tt https\+://web.\+stanford.\+edu/class/cs106l/handouts/assignment-\/3-\/kdtree.\+pdf} \end{DoxyCompactList}\item 
double \hyperlink{classkdtree_a9c74e7b92f12990844c7c5ec9e840c2f}{distance} (std\+::vector$<$ fd $>$ \&data1, std\+::vector$<$ fd $>$ \&data2) const
\item 
bool \hyperlink{classkdtree_a8d48dc9f9e08bf609b94bd6721ef9cbd}{check\+\_\+kdtree} (std\+::vector$<$ fd $>$ \&data) const
\begin{DoxyCompactList}\small\item\em checks if the root is null (or if not tree exists) and returns itself if so. Else, sends the data to another function which performs the same recursively through layers. \end{DoxyCompactList}\item 
bool \hyperlink{classkdtree_a1ae73ba437b116c077d72f1895aeaf52}{check\+\_\+kdtree} (std\+::vector$<$ fd $>$ \&data, std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$$>$ subtree, size\+\_\+t depth=0) const
\begin{DoxyCompactList}\small\item\em iteratively traverses the tree using preorder traversal technique and returns true if any node matches else returns false. \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$ $>$ \hyperlink{classkdtree_a82969cfee401ee863d03ad6ff7488598}{search\+\_\+kdtree} (std\+::vector$<$ fd $>$ \&data) const
\begin{DoxyCompactList}\small\item\em checks if the root is null (or if not tree exists) and returns itself if so. Else, sends the data to another function which performs the same recursively through layers. \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$ $>$ \hyperlink{classkdtree_aeb2f70117e2c254f9e7dc7e23376fa30}{search\+\_\+kdtree} (std\+::vector$<$ fd $>$ \&data, std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$$>$ subtree, std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$$>$ nearest, size\+\_\+t depth=0, double best\+\_\+dist=std\+::numeric\+\_\+limits$<$ fd $>$\+::infinity()) const
\begin{DoxyCompactList}\small\item\em Iterativelyruns through the tree to identify the nearest neighbor using pre order traversal, but this can only solve the problem if the nearest neighbor is on the same brach. Else, it is hard and a legitimate solution has been provided at \href{https://web.stanford.edu/class/cs106l/handouts/assignment-3-kdtree.pdf}{\tt https\+://web.\+stanford.\+edu/class/cs106l/handouts/assignment-\/3-\/kdtree.\+pdf} and the code was inspired from this. \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$ $>$ \hyperlink{classkdtree_a4e8a0ae6cd7464aa0f4ef0f9fb12d211}{serialize\+\_\+tree} (std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$$>$ subtree, std\+::ofstream $\ast$file) const
\begin{DoxyCompactList}\small\item\em stores the data into a file called \textquotesingle{}tree.\+kd\textquotesingle{} \end{DoxyCompactList}\item 
std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$ $>$ \hyperlink{classkdtree_a530cb40f47ab46fb97125028da30744d}{deserialize\+\_\+tree} (std\+::ifstream $\ast$file)
\begin{DoxyCompactList}\small\item\em parses the data in order from the file, thus saving a lot of time in creating the tree for usage. \end{DoxyCompactList}\item 
void \hyperlink{classkdtree_a21c911f32cabf57ea36f5e8083d53532}{print\+\_\+tree} (std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$$>$ subtree) const
\begin{DoxyCompactList}\small\item\em Prints the node using check point so as to see all the data (or) tree. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classkdtree_a938fa159f9e1088db61c8fc34b2d31c9}\label{classkdtree_a938fa159f9e1088db61c8fc34b2d31c9}} 
\index{kdtree@{kdtree}!kdtree@{kdtree}}
\index{kdtree@{kdtree}!kdtree@{kdtree}}
\subsubsection{\texorpdfstring{kdtree()}{kdtree()}}
{\footnotesize\ttfamily template$<$class fd $>$ \\
\hyperlink{classkdtree}{kdtree}$<$ fd $>$\+::\hyperlink{classkdtree}{kdtree} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Constructor for the kd tree. 

Constructor. Creates a tree.


\begin{DoxyParams}{Parameters}
{\em None} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
None 
\end{DoxyReturn}
\mbox{\Hypertarget{classkdtree_aed5e97fa78a51ce22c83874f5ccfc91a}\label{classkdtree_aed5e97fa78a51ce22c83874f5ccfc91a}} 
\index{kdtree@{kdtree}!````~kdtree@{$\sim$kdtree}}
\index{````~kdtree@{$\sim$kdtree}!kdtree@{kdtree}}
\subsubsection{\texorpdfstring{$\sim$kdtree()}{~kdtree()}}
{\footnotesize\ttfamily template$<$class fd $>$ \\
\hyperlink{classkdtree}{kdtree}$<$ fd $>$\+::$\sim$\hyperlink{classkdtree}{kdtree} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Destructor for the kd tree. 

Destructor. All are smart pointers and hence will get destroyed automatically


\begin{DoxyParams}{Parameters}
{\em None} & \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
None 
\end{DoxyReturn}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classkdtree_a8d48dc9f9e08bf609b94bd6721ef9cbd}\label{classkdtree_a8d48dc9f9e08bf609b94bd6721ef9cbd}} 
\index{kdtree@{kdtree}!check\+\_\+kdtree@{check\+\_\+kdtree}}
\index{check\+\_\+kdtree@{check\+\_\+kdtree}!kdtree@{kdtree}}
\subsubsection{\texorpdfstring{check\+\_\+kdtree()}{check\_kdtree()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class fd $>$ \\
bool \hyperlink{classkdtree}{kdtree}$<$ fd $>$\+::check\+\_\+kdtree (\begin{DoxyParamCaption}\item[{std\+::vector$<$ fd $>$ \&}]{data }\end{DoxyParamCaption}) const}



checks if the root is null (or if not tree exists) and returns itself if so. Else, sends the data to another function which performs the same recursively through layers. 


\begin{DoxyParams}{Parameters}
{\em data} & to be checked for. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a boolean value. true if the data exists and false if not. 
\end{DoxyReturn}
\mbox{\Hypertarget{classkdtree_a1ae73ba437b116c077d72f1895aeaf52}\label{classkdtree_a1ae73ba437b116c077d72f1895aeaf52}} 
\index{kdtree@{kdtree}!check\+\_\+kdtree@{check\+\_\+kdtree}}
\index{check\+\_\+kdtree@{check\+\_\+kdtree}!kdtree@{kdtree}}
\subsubsection{\texorpdfstring{check\+\_\+kdtree()}{check\_kdtree()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class fd $>$ \\
bool \hyperlink{classkdtree}{kdtree}$<$ fd $>$\+::check\+\_\+kdtree (\begin{DoxyParamCaption}\item[{std\+::vector$<$ fd $>$ \&}]{data,  }\item[{std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$$>$}]{subtree,  }\item[{size\+\_\+t}]{depth = {\ttfamily 0} }\end{DoxyParamCaption}) const}



iteratively traverses the tree using preorder traversal technique and returns true if any node matches else returns false. 


\begin{DoxyParams}{Parameters}
{\em data} & to be checked for. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a boolean value. true if the data exists and false if not. 
\end{DoxyReturn}
\mbox{\Hypertarget{classkdtree_a530cb40f47ab46fb97125028da30744d}\label{classkdtree_a530cb40f47ab46fb97125028da30744d}} 
\index{kdtree@{kdtree}!deserialize\+\_\+tree@{deserialize\+\_\+tree}}
\index{deserialize\+\_\+tree@{deserialize\+\_\+tree}!kdtree@{kdtree}}
\subsubsection{\texorpdfstring{deserialize\+\_\+tree()}{deserialize\_tree()}}
{\footnotesize\ttfamily template$<$class fd $>$ \\
std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$ $>$ \hyperlink{classkdtree}{kdtree}$<$ fd $>$\+::deserialize\+\_\+tree (\begin{DoxyParamCaption}\item[{std\+::ifstream $\ast$}]{file }\end{DoxyParamCaption})}



parses the data in order from the file, thus saving a lot of time in creating the tree for usage. 


\begin{DoxyParams}{Parameters}
{\em file} & from which data is to be read and the required node of the tree(root by default). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
returns the subtree if it reaches the end of the file. If null, will return the subtree as it is. 
\end{DoxyReturn}
\mbox{\Hypertarget{classkdtree_a9c74e7b92f12990844c7c5ec9e840c2f}\label{classkdtree_a9c74e7b92f12990844c7c5ec9e840c2f}} 
\index{kdtree@{kdtree}!distance@{distance}}
\index{distance@{distance}!kdtree@{kdtree}}
\subsubsection{\texorpdfstring{distance()}{distance()}}
{\footnotesize\ttfamily template$<$class fd $>$ \\
double \hyperlink{classkdtree}{kdtree}$<$ fd $>$\+::distance (\begin{DoxyParamCaption}\item[{std\+::vector$<$ fd $>$ \&}]{data1,  }\item[{std\+::vector$<$ fd $>$ \&}]{data2 }\end{DoxyParamCaption}) const}


\begin{DoxyParams}{Parameters}
{\em Two} & vector data points, within which the euclidean distance is to be identified. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Returns the distance. 
\end{DoxyReturn}
\mbox{\Hypertarget{classkdtree_a42af3021231ec8fceff78d6f309d2571}\label{classkdtree_a42af3021231ec8fceff78d6f309d2571}} 
\index{kdtree@{kdtree}!insert\+\_\+kdtree@{insert\+\_\+kdtree}}
\index{insert\+\_\+kdtree@{insert\+\_\+kdtree}!kdtree@{kdtree}}
\subsubsection{\texorpdfstring{insert\+\_\+kdtree()}{insert\_kdtree()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class fd $>$ \\
std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$ $>$ \hyperlink{classkdtree}{kdtree}$<$ fd $>$\+::insert\+\_\+kdtree (\begin{DoxyParamCaption}\item[{std\+::vector$<$ fd $>$ \&}]{data }\end{DoxyParamCaption})}



Creates the root, if it is null, else, passes it to the another insert function which performs the same function recursively. 


\begin{DoxyParams}{Parameters}
{\em data} & to be inserted \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to the root of the tree so that, it can manipulate wherever required. 
\end{DoxyReturn}
\mbox{\Hypertarget{classkdtree_a6ecd469b21764e96fd222835bef0ed0c}\label{classkdtree_a6ecd469b21764e96fd222835bef0ed0c}} 
\index{kdtree@{kdtree}!insert\+\_\+kdtree@{insert\+\_\+kdtree}}
\index{insert\+\_\+kdtree@{insert\+\_\+kdtree}!kdtree@{kdtree}}
\subsubsection{\texorpdfstring{insert\+\_\+kdtree()}{insert\_kdtree()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class fd $>$ \\
std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$ $>$ \hyperlink{classkdtree}{kdtree}$<$ fd $>$\+::insert\+\_\+kdtree (\begin{DoxyParamCaption}\item[{std\+::vector$<$ fd $>$ \&}]{data,  }\item[{std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$$>$}]{subtree,  }\item[{size\+\_\+t}]{depth = {\ttfamily 0},  }\item[{bool}]{collision = {\ttfamily 0} }\end{DoxyParamCaption})}



the fundamental logic of insertion in kd tree and the explaination can be found at \href{https://web.stanford.edu/class/cs106l/handouts/assignment-3-kdtree.pdf}{\tt https\+://web.\+stanford.\+edu/class/cs106l/handouts/assignment-\/3-\/kdtree.\+pdf} 


\begin{DoxyParams}{Parameters}
{\em data} & to be inserted, layer at which it is to be inserted, the subtree and collision value \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
pointer to the root of the tree so that, it can manipulate wherever required. 
\end{DoxyReturn}
\mbox{\Hypertarget{classkdtree_a21c911f32cabf57ea36f5e8083d53532}\label{classkdtree_a21c911f32cabf57ea36f5e8083d53532}} 
\index{kdtree@{kdtree}!print\+\_\+tree@{print\+\_\+tree}}
\index{print\+\_\+tree@{print\+\_\+tree}!kdtree@{kdtree}}
\subsubsection{\texorpdfstring{print\+\_\+tree()}{print\_tree()}}
{\footnotesize\ttfamily template$<$class fd $>$ \\
void \hyperlink{classkdtree}{kdtree}$<$ fd $>$\+::print\+\_\+tree (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$$>$}]{subtree }\end{DoxyParamCaption}) const}



Prints the node using check point so as to see all the data (or) tree. 


\begin{DoxyParams}{Parameters}
{\em The} & required node of the tree(root by default). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
None 
\end{DoxyReturn}
\mbox{\Hypertarget{classkdtree_a82969cfee401ee863d03ad6ff7488598}\label{classkdtree_a82969cfee401ee863d03ad6ff7488598}} 
\index{kdtree@{kdtree}!search\+\_\+kdtree@{search\+\_\+kdtree}}
\index{search\+\_\+kdtree@{search\+\_\+kdtree}!kdtree@{kdtree}}
\subsubsection{\texorpdfstring{search\+\_\+kdtree()}{search\_kdtree()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$class fd $>$ \\
std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$ $>$ \hyperlink{classkdtree}{kdtree}$<$ fd $>$\+::search\+\_\+kdtree (\begin{DoxyParamCaption}\item[{std\+::vector$<$ fd $>$ \&}]{data }\end{DoxyParamCaption}) const}



checks if the root is null (or if not tree exists) and returns itself if so. Else, sends the data to another function which performs the same recursively through layers. 


\begin{DoxyParams}{Parameters}
{\em data} & to which the nearest neighbor is to be identified. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
returns the pointer to the node which is the nearest neighbor thr given data. 
\end{DoxyReturn}
\mbox{\Hypertarget{classkdtree_aeb2f70117e2c254f9e7dc7e23376fa30}\label{classkdtree_aeb2f70117e2c254f9e7dc7e23376fa30}} 
\index{kdtree@{kdtree}!search\+\_\+kdtree@{search\+\_\+kdtree}}
\index{search\+\_\+kdtree@{search\+\_\+kdtree}!kdtree@{kdtree}}
\subsubsection{\texorpdfstring{search\+\_\+kdtree()}{search\_kdtree()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$class fd $>$ \\
std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$ $>$ \hyperlink{classkdtree}{kdtree}$<$ fd $>$\+::search\+\_\+kdtree (\begin{DoxyParamCaption}\item[{std\+::vector$<$ fd $>$ \&}]{data,  }\item[{std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$$>$}]{subtree,  }\item[{std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$$>$}]{nearest,  }\item[{size\+\_\+t}]{depth = {\ttfamily 0},  }\item[{double}]{best\+\_\+dist = {\ttfamily std\+:\+:numeric\+\_\+limits$<$fd$>$\+:\+:infinity()} }\end{DoxyParamCaption}) const}



Iterativelyruns through the tree to identify the nearest neighbor using pre order traversal, but this can only solve the problem if the nearest neighbor is on the same brach. Else, it is hard and a legitimate solution has been provided at \href{https://web.stanford.edu/class/cs106l/handouts/assignment-3-kdtree.pdf}{\tt https\+://web.\+stanford.\+edu/class/cs106l/handouts/assignment-\/3-\/kdtree.\+pdf} and the code was inspired from this. 


\begin{DoxyParams}{Parameters}
{\em data} & to which the nearest neighbor is to be identified. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
returns the pointer to the node which is the nearest neighbor thr given data. 
\end{DoxyReturn}
\mbox{\Hypertarget{classkdtree_a4e8a0ae6cd7464aa0f4ef0f9fb12d211}\label{classkdtree_a4e8a0ae6cd7464aa0f4ef0f9fb12d211}} 
\index{kdtree@{kdtree}!serialize\+\_\+tree@{serialize\+\_\+tree}}
\index{serialize\+\_\+tree@{serialize\+\_\+tree}!kdtree@{kdtree}}
\subsubsection{\texorpdfstring{serialize\+\_\+tree()}{serialize\_tree()}}
{\footnotesize\ttfamily template$<$class fd $>$ \\
std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$ $>$ \hyperlink{classkdtree}{kdtree}$<$ fd $>$\+::serialize\+\_\+tree (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ \hyperlink{classnode}{node}$<$ fd $>$$>$}]{subtree,  }\item[{std\+::ofstream $\ast$}]{file }\end{DoxyParamCaption}) const}



stores the data into a file called \textquotesingle{}tree.\+kd\textquotesingle{} 


\begin{DoxyParams}{Parameters}
{\em file} & to which data is to be written and the required node of the tree(root by default). \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
returns the subtree if it reaches the end of the file. If null, will return the subtree as it is. 
\end{DoxyReturn}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
\hyperlink{kdtree_8h}{kdtree.\+h}\item 
\hyperlink{kdtree__utils_8cpp}{kdtree\+\_\+utils.\+cpp}\end{DoxyCompactItemize}
