<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kd Tree: kdspace Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kd Tree
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">AKdTreeimplementationinC++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">kdspace Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdspace_1_1median__data.html">median_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Median_Data: This class serves to be a holder of a bunch of data, namely, the point at which the data was split and the data to the left and the data to the right.  <a href="classkdspace_1_1median__data.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae38cb61fa0fc73b8cced4a1bc0fb1d58"><td class="memTemplParams" colspan="2">template&lt;typename fd &gt; </td></tr>
<tr class="memitem:ae38cb61fa0fc73b8cced4a1bc0fb1d58"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekdspace.html#ae38cb61fa0fc73b8cced4a1bc0fb1d58">parser</a> (std::vector&lt; std::vector&lt; fd &gt;&gt; *whole_data, std::ifstream *file)</td></tr>
<tr class="memdesc:ae38cb61fa0fc73b8cced4a1bc0fb1d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the containers, and later, using stringstream the data in the file is parsed and then pushed back into the vector.  <a href="#ae38cb61fa0fc73b8cced4a1bc0fb1d58">More...</a><br /></td></tr>
<tr class="separator:ae38cb61fa0fc73b8cced4a1bc0fb1d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2e28665e0ac98030cc9b0d8e017435"><td class="memTemplParams" colspan="2">template&lt;typename fd &gt; </td></tr>
<tr class="memitem:a0c2e28665e0ac98030cc9b0d8e017435"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classnode.html">node</a>&lt; fd &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekdspace.html#a0c2e28665e0ac98030cc9b0d8e017435">grow_kdtree</a> (<a class="el" href="classkdtree.html">kdtree</a>&lt; fd &gt; *tree, std::vector&lt; fd &gt; &amp;data)</td></tr>
<tr class="memdesc:a0c2e28665e0ac98030cc9b0d8e017435"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an interface function and hence takes care of the necessary functionalities in order to use the 'insert_tree' function.  <a href="#a0c2e28665e0ac98030cc9b0d8e017435">More...</a><br /></td></tr>
<tr class="separator:a0c2e28665e0ac98030cc9b0d8e017435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b05e61a7246f9455a62996475eb7bf2"><td class="memTemplParams" colspan="2">template&lt;typename fd &gt; </td></tr>
<tr class="memitem:a4b05e61a7246f9455a62996475eb7bf2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekdspace.html#a4b05e61a7246f9455a62996475eb7bf2">get_split_axis</a> (int *axis, std::vector&lt; std::vector&lt; fd &gt;&gt; *dataset, const size_t val=0, const size_t depth=0)</td></tr>
<tr class="memdesc:a4b05e61a7246f9455a62996475eb7bf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This decides the axis on which the data is to split. This value maintains the balance of the tree.  <a href="#a4b05e61a7246f9455a62996475eb7bf2">More...</a><br /></td></tr>
<tr class="separator:a4b05e61a7246f9455a62996475eb7bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7e287c43237fb7400437c8ecf955f3"><td class="memTemplParams" colspan="2">template&lt;typename fd &gt; </td></tr>
<tr class="memitem:a4f7e287c43237fb7400437c8ecf955f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekdspace.html#a4f7e287c43237fb7400437c8ecf955f3">get_median</a> (std::shared_ptr&lt; <a class="el" href="classkdspace_1_1median__data.html">median_data</a>&lt; fd &gt; &gt; median_details, std::vector&lt; std::vector&lt; fd &gt;&gt; *dataset, const double val=0.5)</td></tr>
<tr class="memdesc:a4f7e287c43237fb7400437c8ecf955f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This chooses the split position given a dimension to split on from the 'get_split_axis' function. This too determines the balance of the tree. The value can range anywhere between 0 and 1 (both not included). If not will return exception.  <a href="#a4f7e287c43237fb7400437c8ecf955f3">More...</a><br /></td></tr>
<tr class="separator:a4f7e287c43237fb7400437c8ecf955f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3221e9795dbfa52b58ac53740c4a4354"><td class="memTemplParams" colspan="2">template&lt;typename fd &gt; </td></tr>
<tr class="memitem:a3221e9795dbfa52b58ac53740c4a4354"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekdspace.html#a3221e9795dbfa52b58ac53740c4a4354">distance</a> (const std::vector&lt; fd &gt; &amp;data1, std::vector&lt; fd &gt; &amp;data2)</td></tr>
<tr class="separator:a3221e9795dbfa52b58ac53740c4a4354"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A namespace to hold some of the important functions pertaining to the functioning and interfacing to the classes to the required functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a3221e9795dbfa52b58ac53740c4a4354"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3221e9795dbfa52b58ac53740c4a4354">&#9670;&nbsp;</a></span>distance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename fd &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double kdspace::distance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; fd &gt; &amp;&#160;</td>
          <td class="paramname"><em>data1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; fd &gt; &amp;&#160;</td>
          <td class="paramname"><em>data2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Two</td><td>vector data points, within which the euclidean distance is to be identified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the distance. </dd></dl>

</div>
</div>
<a id="a4f7e287c43237fb7400437c8ecf955f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7e287c43237fb7400437c8ecf955f3">&#9670;&nbsp;</a></span>get_median()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename fd &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void kdspace::get_median </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classkdspace_1_1median__data.html">median_data</a>&lt; fd &gt; &gt;&#160;</td>
          <td class="paramname"><em>median_details</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; fd &gt;&gt; *&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>val</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This chooses the split position given a dimension to split on from the 'get_split_axis' function. This too determines the balance of the tree. The value can range anywhere between 0 and 1 (both not included). If not will return exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>pointer to the class containerto hold the median details. The complete dataset to recursively, split it and the hyperparameter to choose and move the split position in the decided dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split data is inserted to the class object and it reflects in the called location. Hence, does not return anything. </dd></dl>

</div>
</div>
<a id="a4b05e61a7246f9455a62996475eb7bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b05e61a7246f9455a62996475eb7bf2">&#9670;&nbsp;</a></span>get_split_axis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename fd &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void kdspace::get_split_axis </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; fd &gt;&gt; *&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>val</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This decides the axis on which the data is to split. This value maintains the balance of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>holder of type vector of vector which holds the complete data. Container to fill in the split axis, and values that determine which splitting strategy is to be used. By default, both the vaues, remain 0, that is, it figures out the dimension which has the greatest variance. Parameter 'val' can be changed to 1 to get the dimension with least variance leading to the worst heuristic possible. If it is neither 0 nor 1, code expects the depth value and will return it as same and this can be utilized to determine as=ny user defined strategy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Values were filled into the concerned containers and hence does not return anything. </dd></dl>

</div>
</div>
<a id="a0c2e28665e0ac98030cc9b0d8e017435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2e28665e0ac98030cc9b0d8e017435">&#9670;&nbsp;</a></span>grow_kdtree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename fd &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classnode.html">node</a> &lt;fd&gt; &gt; kdspace::grow_kdtree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkdtree.html">kdtree</a>&lt; fd &gt; *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; fd &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an interface function and hence takes care of the necessary functionalities in order to use the 'insert_tree' function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>tree into which the provided data is to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The root or head of the tree is returned so that, the root of the tree can always be accessed from anywhere in the main function. </dd></dl>

</div>
</div>
<a id="ae38cb61fa0fc73b8cced4a1bc0fb1d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae38cb61fa0fc73b8cced4a1bc0fb1d58">&#9670;&nbsp;</a></span>parser()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename fd &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void kdspace::parser </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; fd &gt;&gt; *&#160;</td>
          <td class="paramname"><em>whole_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ifstream *&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the containers, and later, using stringstream the data in the file is parsed and then pushed back into the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>holder of type vector of vector into which the parsed data will be filled. A file which holds the data to be parsed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Values were filled into the concerned containersa and hence does not return anything. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
