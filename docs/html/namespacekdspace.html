<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>My Project: kdspace Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">kdspace Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkdspace_1_1median__data.html">median_data</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Median_Data: This class serves to be a holder of a bunch of data, namely, the point at which the data was split and the data to the left and the data to the right.  <a href="classkdspace_1_1median__data.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae38cb61fa0fc73b8cced4a1bc0fb1d58"><td class="memTemplParams" colspan="2">template&lt;typename fd &gt; </td></tr>
<tr class="memitem:ae38cb61fa0fc73b8cced4a1bc0fb1d58"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekdspace.html#ae38cb61fa0fc73b8cced4a1bc0fb1d58">parser</a> (std::vector&lt; std::vector&lt; fd &gt;&gt; *whole_data, std::ifstream *file)</td></tr>
<tr class="memdesc:ae38cb61fa0fc73b8cced4a1bc0fb1d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the containers, and later, using stringstream the data in the file is parsed and then pushed back into the vector.  <a href="#ae38cb61fa0fc73b8cced4a1bc0fb1d58">More...</a><br/></td></tr>
<tr class="separator:ae38cb61fa0fc73b8cced4a1bc0fb1d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed82e0d7ec733c0e3a0e354dd0026e4b"><td class="memTemplParams" colspan="2">template&lt;typename fd &gt; </td></tr>
<tr class="memitem:aed82e0d7ec733c0e3a0e354dd0026e4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekdspace.html#aed82e0d7ec733c0e3a0e354dd0026e4b">grow_kdtree</a> (<a class="el" href="classkdtree.html">kdtree</a>&lt; fd &gt; *tree, std::vector&lt; fd &gt; &amp;data)</td></tr>
<tr class="memdesc:aed82e0d7ec733c0e3a0e354dd0026e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an interface function and hence takes care of the necessary functionalities in order to use the 'insert_tree' function.  <a href="#aed82e0d7ec733c0e3a0e354dd0026e4b">More...</a><br/></td></tr>
<tr class="separator:aed82e0d7ec733c0e3a0e354dd0026e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f456b7acaa6bb56f45158655aa1f83"><td class="memTemplParams" colspan="2">template&lt;typename fd &gt; </td></tr>
<tr class="memitem:a83f456b7acaa6bb56f45158655aa1f83"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekdspace.html#a83f456b7acaa6bb56f45158655aa1f83">get_split_axis</a> (int *axis, const std::vector&lt; std::vector&lt; fd &gt;&gt; *dataset, const size_t val=0, const size_t depth=0)</td></tr>
<tr class="memdesc:a83f456b7acaa6bb56f45158655aa1f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This decides the axis on which the data is to split. This value maintains the balance of the tree.  <a href="#a83f456b7acaa6bb56f45158655aa1f83">More...</a><br/></td></tr>
<tr class="separator:a83f456b7acaa6bb56f45158655aa1f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7e287c43237fb7400437c8ecf955f3"><td class="memTemplParams" colspan="2">template&lt;typename fd &gt; </td></tr>
<tr class="memitem:a4f7e287c43237fb7400437c8ecf955f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekdspace.html#a4f7e287c43237fb7400437c8ecf955f3">get_median</a> (std::shared_ptr&lt; <a class="el" href="classkdspace_1_1median__data.html">median_data</a>&lt; fd &gt; &gt; median_details, std::vector&lt; std::vector&lt; fd &gt;&gt; *dataset, const double val=0.5)</td></tr>
<tr class="memdesc:a4f7e287c43237fb7400437c8ecf955f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This chooses the split position given a dimension to split on from the 'get_split_axis' function. This too determines the balance of the tree. The value can range anywhere between 0 and 1 (both not included). If not will return exception.  <a href="#a4f7e287c43237fb7400437c8ecf955f3">More...</a><br/></td></tr>
<tr class="separator:a4f7e287c43237fb7400437c8ecf955f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7273e612072ca0ae8689762a3c224da9"><td class="memTemplParams" colspan="2">template&lt;typename fd &gt; </td></tr>
<tr class="memitem:a7273e612072ca0ae8689762a3c224da9"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacekdspace.html#a7273e612072ca0ae8689762a3c224da9">distance</a> (const std::vector&lt; fd &gt; &amp;data1, const std::vector&lt; fd &gt; &amp;data2)</td></tr>
<tr class="separator:a7273e612072ca0ae8689762a3c224da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a023c33dca0725913887ec75fe8f49373"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekdspace.html#a023c33dca0725913887ec75fe8f49373">serialization_flag</a> = false</td></tr>
<tr class="separator:a023c33dca0725913887ec75fe8f49373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78984ac844171865e7f2c0747f8f5862"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacekdspace.html#a78984ac844171865e7f2c0747f8f5862">print_flag</a> = false</td></tr>
<tr class="separator:a78984ac844171865e7f2c0747f8f5862"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A namespace to hold some of the important functions pertaining to the functioning and interfacing to the classes to the required functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a7273e612072ca0ae8689762a3c224da9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename fd &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double kdspace::distance </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; fd &gt; &amp;&#160;</td>
          <td class="paramname"><em>data1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; fd &gt; &amp;&#160;</td>
          <td class="paramname"><em>data2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Two</td><td>vector data points, within which the euclidean distance is to be identified. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the distance. </dd></dl>

</div>
</div>
<a class="anchor" id="a4f7e287c43237fb7400437c8ecf955f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename fd &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void kdspace::get_median </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; median_data&lt; fd &gt; &gt;&#160;</td>
          <td class="paramname"><em>median_details</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; fd &gt;&gt; *&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>val</em> = <code>0.5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This chooses the split position given a dimension to split on from the 'get_split_axis' function. This too determines the balance of the tree. The value can range anywhere between 0 and 1 (both not included). If not will return exception. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>pointer to the class containerto hold the median details. The complete dataset to recursively, split it and the hyperparameter to choose and move the split position in the decided dimension. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The split data is inserted to the class object and it reflects in the called location. Hence, does not return anything. </dd></dl>

</div>
</div>
<a class="anchor" id="a83f456b7acaa6bb56f45158655aa1f83"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename fd &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void kdspace::get_split_axis </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; fd &gt;&gt; *&#160;</td>
          <td class="paramname"><em>dataset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>val</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>depth</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This decides the axis on which the data is to split. This value maintains the balance of the tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>holder of type vector of vector which holds the complete data. Container to fill in the split axis, and values that determine which splitting strategy is to be used. By default, both the vaues, remain 0, that is, it figures out the dimension which has the greatest variance. Parameter 'val' can be changed to 1 to get the dimension with least variance leading to the worst heuristic possible. If it is neither 0 nor 1, code expects the depth value and will return it as same and this can be utilized to determine as=ny user defined strategy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Values were filled into the concerned containers and hence does not return anything. </dd></dl>

</div>
</div>
<a class="anchor" id="aed82e0d7ec733c0e3a0e354dd0026e4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename fd &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void kdspace::grow_kdtree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classkdtree.html">kdtree</a>&lt; fd &gt; *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; fd &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is an interface function and hence takes care of the necessary functionalities in order to use the 'insert_tree' function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">The</td><td>tree into which the provided data is to be inserted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. Inserts the given given data into the tree. </dd></dl>

</div>
</div>
<a class="anchor" id="ae38cb61fa0fc73b8cced4a1bc0fb1d58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename fd &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void kdspace::parser </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; fd &gt;&gt; *&#160;</td>
          <td class="paramname"><em>whole_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ifstream *&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the containers, and later, using stringstream the data in the file is parsed and then pushed back into the vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>holder of type vector of vector into which the parsed data will be filled. A file which holds the data to be parsed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Values were filled into the concerned containers a and hence does not return anything. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a78984ac844171865e7f2c0747f8f5862"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kdspace::print_flag = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag to avoid seg faults when repeatedly printed and to actovate calls from root with no parameters </p>

</div>
</div>
<a class="anchor" id="a023c33dca0725913887ec75fe8f49373"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kdspace::serialization_flag = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag to avoid seg faults when repeatedly printed and to actovate calls from root with no parameters </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 13 2017 15:01:58 for My Project by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
